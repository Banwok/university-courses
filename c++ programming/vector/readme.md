# Vector

В этой задаче вам нужно реализовать упрощенный аналог шаблонного класса `std::vector`. Для этого определите класс `Vector`, в котором
будут храниться инты и есть:

* Конструктор по умолчанию.
* Конструктор, принимающий размер вектора и заполняющий его нулями.
* Конструктор, принимающий список инициализации `std::initializer_list<int>`, что позволяет писать `Vector a{1, 3, 5}`.
* Конструктор копирования и конструктор перемещения.
* Оператор присваивания, копирующий и перемещающий.
* Деструктор.
* Метод `Swap`, принимающий другой вектор по ссылке и меняющий содержимое текущего вектора с ним местами.
* Операторы индексирования [ ], константный и нет. Последний должен позволять изменять содержимое по индексу.
* Метод `Size`, возвращающий число элементов в векторе.
* Метод `Capacity`, возвращающий текущее число выделенных ячеек памяти под вектор.
* Метод `PushBack`, который вставляет элемент в конец вектора. Если при этом память, выделенная для вектора, заполнена, то выполните
реаллокацию: выделите массив вдвое большего размера, скопируйте (или переместите) элементы туда, после чего удалите старый массив. В
этом случае `Capacity` также должен увеличиться вдвое.
* Метод `PopBack`, который удаляет последний элемент вектора. Сужать вектор при этом не нужно, должен измениться только `Size`.
* Метод `Clear`, опустошающий вектор. Аналогично, сужать его при этом не нужно, `Size` должен стать нулевым.
* Метод `Reserve`, который принимает новое значение `capacity`, позволяя зарезервировать место в векторе. Если текущий `Capacity` не
меньше переданного, то метод не должен ничего делать. В противном случае выполните реаллокацию в массив размера `capacity`.
* Методы `Begin` и `End`, возвращающие итераторы на первый элемент вектора и следующий за последним. Также определите их аналоги
`begin` и `end`, чтобы c вашим вектором можно было работать с помощью range-based for.

Чтобы реализовать итераторы, определите внутри вашего класса `Vector` еще один класс `Iterator` и унаследуйте его от `std::iterator`,
    указав правильную категорию и итерируемый тип. Ваш итератор должен быть random access, т.е. удовлетворять описанным тут требованиям:
    https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator. В этой задаче эти требования чуть упрощены --- вы можете не
    реализовывать для итератора [ ] и операторы сравнения (кроме == и !=). Все остальные операции в тестах используются.

### Примечания

* В этой задаче вам запрещено использовать стандартные контейнеры и умные указатели, поэтому аккуратно управляйте памятью.
* Согласно требованиям к stl-совместимому итератору, в нем должны быть определены некоторые типы, такие как `value_type` и некоторые
другие. Наследуя свой итератор от `std::iterator`, вы избавляете себя от необходимости определять эти типы в своем классе вручную.
* Iterator должен быть неконстантным, т.е. с его помощью можно изменять элементы последовательности (см. тесты).
* Обратите внимание, что range-based for работает с коллекцией только в том случае, если в ней есть методы begin и end или определены
внешние функции begin и end, принимающие заданную коллекцию. Именно поэтому мы дополнительно определяем эти методы в классе с именами,
    не соответствующими стайлгайду.
При этом clang-tidy не разрешит вам сделать методы с такими именами, поэтому используйте комментарий `// NOLINT`, после заголовка метода.
