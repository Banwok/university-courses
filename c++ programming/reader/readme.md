# Reader

В этой задаче мы будем работать с интерфейсом Reader.
Интерфейс Reader абстрагирует входной поток байт (который может быть бесконечным).
Такая абстракция часто возникает в библиотеках для работы с форматами данных. [Раз](https://github.com/google/snappy/blob/master/snappy-sinksource.h#L111) [Два](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.zero_copy_stream).

В интерфейсе есть всего один метод `size_t Read(char* buf, size_t len)`.

* Метод должен читать не более len байт в массив buf.
* Метод должен возвращать, сколько байт удалось прочитать.
* Возвращаемое значение 0 означает конец потока.

Вам нужно реализовать 3 класса `LimitReader`, `TeeReader` и `HexDecodingReader` в файле `readers_util.h`:

* `LimitReader` --- это поток байт, который является префиксом исходного потока байт и имеет длину min(limit, длина исходного потока).
То есть, `LimitReader` должен читать не более чем limit байт из исходного потока, а затем говорить, что поток кончился.
* `TeeReader` --- это поток байт, который является конкатенацией всех исходных потоков.
То есть, `TeeReader` должен читать первый исходный поток, затем второй поток и т.д.
* `HexDecodingReader` --- это поток байт, который получается после раскодирования исходного потока из кодировки Hex.
Считайте, что исходный поток является корректным Hex числом --- имеет четную длину и состоит только из символов [0-9a-f].

### Примечания

* Некоторые примеры ридеров вы можете найти в файле `reader.h`.
* Обратите внимание, что функция `ReadAll` принимает указатель `Reader *in`. За счет полиморфизма реально in может указывать на
произвольный объект, реализующий интерфейс Reader, благодаря чему функция может работать с любым ридером.
